
(function() {
    'use strict';
    
    const __modules__ = {};
    const __cache__ = {};
    
    function __require__(moduleName) {
        if (__cache__[moduleName]) {
            return __cache__[moduleName];
        }
        
        if (!__modules__[moduleName]) {
            throw new Error('Module not found: ' + moduleName);
        }
        
        const module = { exports: {} };
        const result = __modules__[moduleName].call(module.exports, __require__, module, module.exports);
        
        __cache__[moduleName] = result || module.exports;
        return __cache__[moduleName];
    }
    
    __modules__['app'] = function(__require__, module, exports) {
        const Game = __modules__['core/Game.js'] || {}; class App {constructor() {this.game = null; this.isInitialized = false}async init() {try {console.log('Initializing Math Super Game...'); this.setupGlobalErrorHandling(); await this.waitForDOM(); this.game = new Game(); await this.game.initialize(); this.setupGlobalEventListeners(); this.isInitialized = true; console.log('Math Super Game initialized successfully!'); this.game.eventBus.emit('appReady')}catch (error) {console.error('Failed to initialize app:',error); this.showInitializationError(error)}}waitForDOM() {return new Promise((resolve) => {if (document.readyState === 'loading') {document.addEventListener('DOMContentLoaded',resolve)}else {resolve()}})}setupGlobalErrorHandling() {window.addEventListener('error',(event) => {console.error('Global error:',event.error); this.handleGlobalError(event.error)}); window.addEventListener('unhandledrejection',(event) => {console.error('Unhandled promise rejection:',event.reason); this.handleGlobalError(event.reason)})}setupGlobalEventListeners() {this.setupOperationButtons(); this.setupGameControls(); this.setupKeyboardShortcuts(); this.setupTouchOptimizations(); this.setupAccessibilityFeatures()}setupOperationButtons() {const operationButtons = [ {id: 'addition-btn',operation: 'addition' },{id: 'subtraction-btn',operation: 'subtraction' },{id: 'multiplication-btn',operation: 'multiplication' },{id: 'division-btn',operation: 'division' },{id: 'supermode-btn',operation: 'supermode' },{id: 'detective-btn',operation: 'detective' }]; operationButtons.forEach(({id,operation }) => {const button = document.getElementById(id); if (button) {button.addEventListener('click',() => {this.game.soundService.resumeAudioContext(); this.game.startGame(operation)})}}); const legacyButtons = document.querySelectorAll('[onclick*="startGame"]'); legacyButtons.forEach(button => {const onclickAttr = button.getAttribute('onclick'); if (onclickAttr) {const match = onclickAttr.match(/startGame\('(\w+)'\)/); if (match) {const operation = match[1]; button.removeAttribute('onclick'); button.addEventListener('click',() => {this.game.soundService.resumeAudioContext(); this.game.startGame(operation)})}}})}setupGameControls() {const checkBtn = document.getElementById('check-btn'); if (checkBtn) {checkBtn.removeAttribute('onclick'); checkBtn.addEventListener('click',() => {this.game.checkAnswer()})}const changeModeBtn = document.querySelector('[onclick*="endGame"]'); if (changeModeBtn) {changeModeBtn.removeAttribute('onclick'); changeModeBtn.addEventListener('click',() => {this.game.showMainMenu()})}const answerInput = document.getElementById('answer-input'); if (answerInput) {answerInput.addEventListener('keypress',(e) => {if (e.key === 'Enter') {this.game.checkAnswer()}}); answerInput.addEventListener('input',(e) => {const value = e.target.value; if (value && !/^\d*$/.test(value)) {e.target.value = value.replace(/\D/g,'')}})}}setupKeyboardShortcuts() {document.addEventListener('keydown',(e) => {if (this.game && this.game.isInitialized) {switch (e.key) {case '1': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('addition')}break; case '2': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('subtraction')}break; case '3': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('multiplication')}break; case '4': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('division')}break; case '5': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('supermode')}break; case '6': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.game.startGame('detective')}break; case 'Escape': if (this.game.gameState.getState().currentScreen === 'game') {this.game.showMainMenu()}break; case 'h': if (e.ctrlKey || e.metaKey) {e.preventDefault(); this.showHelpModal()}break}}})}setupTouchOptimizations() {if ('ontouchstart' in window) {document.body.classList.add('touch-device'); let touchStartTime = 0; document.addEventListener('touchstart',(e) => {touchStartTime = Date.now(); this.game?.soundService.resumeAudioContext()}); document.addEventListener('touchend',(e) => {const touchDuration = Date.now() - touchStartTime; if (touchDuration > 500) {e.target.classList.add('long-press'); setTimeout(() => {e.target.classList.remove('long-press')},200)}}); const buttons = document.querySelectorAll('.btn,button'); buttons.forEach(button => {button.addEventListener('touchstart',() => {button.classList.add('touch-active')}); button.addEventListener('touchend',() => {setTimeout(() => {button.classList.remove('touch-active')},150)})})}}setupAccessibilityFeatures() {const focusableElements = document.querySelectorAll( 'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])' ); focusableElements.forEach((element,index) => {if (!element.getAttribute('tabindex')) {element.setAttribute('tabindex','0')}element.addEventListener('focus',() => {element.classList.add('focus-visible'); this.announceForScreenReader(`Focused on ${this.getElementDescription(element)}`)}); element.addEventListener('blur',() => {element.classList.remove('focus-visible')})}); const answerInput = document.getElementById('answer-input'); if (answerInput) {answerInput.setAttribute('aria-label','Enter your answer'); answerInput.setAttribute('aria-describedby','answer-hint'); const hint = document.createElement('div'); hint.id = 'answer-hint'; hint.className = 'sr-only'; hint.textContent = 'Enter a number and press Enter or click Check'; answerInput.parentNode.appendChild(hint)}const scoreDisplay = document.getElementById('score'); if (scoreDisplay) {scoreDisplay.setAttribute('aria-live','polite'); scoreDisplay.setAttribute('aria-label','Current score')}}getElementDescription(element) {const tagName = element.tagName.toLowerCase(); const text = element.textContent?.trim() || element.value || element.alt || ''; const ariaLabel = element.getAttribute('aria-label'); return ariaLabel || text || `${tagName}element`}announceForScreenReader(message) {const announcement = document.createElement('div'); announcement.setAttribute('aria-live','assertive'); announcement.setAttribute('aria-atomic','true'); announcement.className = 'sr-only'; announcement.textContent = message; document.body.appendChild(announcement); setTimeout(() => {document.body.removeChild(announcement)},1000)}handleGlobalError(error) {if (this.game && this.game.modalManager) {this.game.modalManager.create('global-error',{title: 'Oops! Something went wrong',content: ` <p class="mb-4">We encountered an unexpected error:</p> <p class="text-sm text-gray-600 mb-4">${error.message || 'Unknown error'}</p> <p>Don't worry,your progress has been saved. You can continue playing!</p> `,type: 'error',buttons: [ {text: 'Continue Playing',type: 'primary',action: 'continue' },{text: 'Restart Game',type: 'secondary',action: 'restart' }] }); this.game.eventBus.on('modalButtonClick',(data) => {if (data.modalId === 'global-error') {if (data.action === 'restart') {this.restart()}else {this.game.modalManager.close('global-error')}}}); this.game.modalManager.show('global-error')}else {console.error('Cannot show error modal,falling back to alert'); alert('An error occurred. Please refresh the page.')}}showInitializationError(error) {const errorContainer = document.createElement('div'); errorContainer.innerHTML = ` <div class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50"> <div class="bg-white rounded-2xl p-8 max-w-md text-center"> <h2 class="text-2xl font-bold text-red-600 mb-4">Initialization Error</h2> <p class="mb-4">Failed to start the Math Super Game:</p> <p class="text-sm text-gray-600 mb-6">${error.message}</p> <button onclick="window.location.reload()" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-6 rounded-xl"> Refresh Page </button> </div> </div> `; document.body.appendChild(errorContainer)}showHelpModal() {if (!this.game || !this.game.modalManager) return; this.game.modalManager.create('help',{title: 'üéÆ How to Play',content: ` <div class="text-left space-y-4"> <div> <h4 class="font-bold mb-2">üî¢ Choose Your Operation:</h4> <p class="text-sm text-gray-600">Pick Addition (+),Subtraction (-),Multiplication (√ó),Division (√∑),Super Mode (mixed operations),or Detective Mode (find the missing number).</p> </div> <div> <h4 class="font-bold mb-2">üëÄ Look at the Blocks:</h4> <p class="text-sm text-gray-600">Use the colorful blocks to help visualize the math problem.</p> </div> <div> <h4 class="font-bold mb-2">‚úèÔ∏è Enter Your Answer:</h4> <p class="text-sm text-gray-600">Type your answer in the box and press Enter or click Check.</p> </div> <div> <h4 class="font-bold mb-2">üèÜ Earn Points & Achievements:</h4> <p class="text-sm text-gray-600">Get points for correct answers and unlock medals!</p> </div> <div> <h4 class="font-bold mb-2">‚å®Ô∏è Keyboard Shortcuts:</h4> <p class="text-sm text-gray-600"> Ctrl+1: Addition | Ctrl+2: Subtraction | Ctrl+3: Multiplication<br> Ctrl+4: Division | Ctrl+5: Super Mode | Ctrl+6: Detective Mode<br> Escape: Main Menu </p> </div> </div> `,size: 'large',buttons: [ {text: 'Got it!',type: 'primary',action: 'close' }] }); this.game.modalManager.show('help')}async restart() {try {if (this.game) {this.game.destroy()}this.game = new Game(); await this.game.initialize(); console.log('Game restarted successfully')}catch (error) {console.error('Failed to restart game:',error); window.location.reload()}}getStatus() {return {initialized: this.isInitialized,game: this.game ? this.game.getGameStatus() : null,timestamp: new Date().toISOString() }}}const app = new App(); window.addEventListener('load',() => {app.init().catch(console.error)}); window.mathSuperGame = app; return app;
    };

    __modules__['core/EventBus'] = function(__require__, module, exports) {
        class EventBus {constructor() {this.events = new Map()}on(eventName,callback) {if (!this.events.has(eventName)) {this.events.set(eventName,[])}this.events.get(eventName).push(callback); return () => this.off(eventName,callback)}off(eventName,callback) {if (this.events.has(eventName)) {const callbacks = this.events.get(eventName); const index = callbacks.indexOf(callback); if (index > -1) {callbacks.splice(index,1)}}}emit(eventName,data) {if (this.events.has(eventName)) {this.events.get(eventName).forEach(callback => {try {callback(data)}catch (error) {console.error(`Error in event listener for ${eventName}:`,error)}})}}once(eventName,callback) {const onceCallback = (data) => {callback(data); this.off(eventName,onceCallback)}; this.on(eventName,onceCallback)}clear(eventName) {if (eventName) {this.events.delete(eventName)}else {this.events.clear()}}}return EventBus;
    };

    __modules__['core/Game'] = function(__require__, module, exports) {
        const EventBus = __modules__['core/EventBus.js'] || {}; const GameState = __modules__['core/GameState.js'] || {}; const Player = __modules__['/Users/sg/Work/supermath/models/Player.js'] || {}; const Question = __modules__['/Users/sg/Work/supermath/models/Question.js'] || {}; const {Achievement,ACHIEVEMENT_DEFINITIONS }= __modules__['/Users/sg/Work/supermath/models/Achievement.js'] || {}; const StorageService = __modules__['/Users/sg/Work/supermath/services/StorageService.js'] || {}; const APIService = __modules__['/Users/sg/Work/supermath/services/APIService.js'] || {}; const SoundService = __modules__['/Users/sg/Work/supermath/services/SoundService.js'] || {}; const BlockVisualizer = __modules__['/Users/sg/Work/supermath/ui/components/BlockVisualizer.js'] || {}; const ModalManager = __modules__['/Users/sg/Work/supermath/ui/components/ModalManager.js'] || {}; const ScoreDisplay = __modules__['/Users/sg/Work/supermath/ui/components/ScoreDisplay.js'] || {}; const Addition = __modules__['/Users/sg/Work/supermath/operations/Addition.js'] || {}; const Subtraction = __modules__['/Users/sg/Work/supermath/operations/Subtraction.js'] || {}; const Multiplication = __modules__['/Users/sg/Work/supermath/operations/Multiplication.js'] || {}; const Division = __modules__['/Users/sg/Work/supermath/operations/Division.js'] || {}; const SuperMode = __modules__['/Users/sg/Work/supermath/operations/SuperMode.js'] || {}; const DetectiveOperation = __modules__['/Users/sg/Work/supermath/operations/DetectiveOperation.js'] || {}; class Game {constructor() {this.eventBus = new EventBus(); this.gameState = new GameState(this.eventBus); this.storageService = new StorageService(); this.apiService = new APIService(); this.soundService = new SoundService(); this.blockVisualizer = new BlockVisualizer(this.eventBus); this.modalManager = new ModalManager(this.eventBus); this.scoreDisplay = new ScoreDisplay(this.eventBus); this.operations = {addition: new Addition(),subtraction: new Subtraction(),multiplication: new Multiplication(),division: new Division(),supermode: new SuperMode(),detective: new DetectiveOperation() }; this.achievements = new Map(); this.player = null; this.currentQuestion = null; this.isInitialized = false; this.setupEventListeners()}async initialize() {if (this.isInitialized) return; try {await this.loadPlayer(); this.loadAchievements(); this.applyPlayerSettings(); this.setupUI(); this.setupKeyboardListeners(); this.isInitialized = true; this.eventBus.emit('gameInitialized'); console.log('Math Super Game initialized successfully')}catch (error) {console.error('Error initializing game:',error); this.handleInitializationError(error)}}setupEventListeners() {this.eventBus.on('stateChanged',(data) => {this.handleStateChange(data)}); this.eventBus.on('visualizationComplete',(data) => {this.handleVisualizationComplete(data)}); this.eventBus.on('modalButtonClick',(data) => {this.handleModalButtonClick(data)}); this.eventBus.on('achievementUnlocked',(data) => {this.handleAchievementUnlocked(data)})}async loadPlayer() {const playerData = this.storageService.getPlayerData(); if (playerData) {this.player = Player.fromJSON(playerData)}else {this.player = new Player(); this.storageService.savePlayerData(this.player.toJSON())}this.gameState.setState({player: this.player })}loadAchievements() {Object.values(ACHIEVEMENT_DEFINITIONS).flat().forEach(achievementData => {const achievement = new Achievement(achievementData); this.achievements.set(achievement.id,achievement)})}applyPlayerSettings() {if (!this.player) return; const settings = this.player.settings; if (settings.soundEnabled !== undefined) {this.soundService.setEnabled(settings.soundEnabled)}if (settings.musicEnabled !== undefined) {this.soundService.setMusicEnabled(settings.musicEnabled); if (settings.musicEnabled) {setTimeout(() => {this.soundService.startBackgroundMusic()},1000)}}this.updateSettingsUI()}updateSettingsUI() {if (!this.player) return; const settings = this.player.settings; const difficultySelect = document.getElementById('difficulty-select'); if (difficultySelect && settings.difficulty) {difficultySelect.value = settings.difficulty}const soundToggle = document.getElementById('sound-toggle'); if (soundToggle) {soundToggle.checked = settings.soundEnabled !== false}const musicToggle = document.getElementById('music-toggle'); if (musicToggle) {musicToggle.checked = settings.musicEnabled !== false}}setupUI() {this.scoreDisplay.register('score','total'); this.scoreDisplay.register('level-display','level'); this.scoreDisplay.register('streak-display','streak'); this.updateScoreDisplay(); this.showMainMenu()}setupKeyboardListeners() {document.addEventListener('keydown',(e) => {if (this.gameState.getState().currentScreen === 'game') {if (e.key === 'Enter') {const answerInput = document.getElementById('answer-input'); if (answerInput && document.activeElement === answerInput) {this.checkAnswer()}}else if (e.key === 'Escape') {this.showMainMenu()}}})}showMainMenu() {this.gameState.setState({currentScreen: 'menu',isGameActive: false }); const modeSelection = document.getElementById('mode-selection'); const gameArea = document.getElementById('game-area'); if (modeSelection) modeSelection.classList.remove('hidden'); if (gameArea) gameArea.classList.add('hidden'); this.updateScoreDisplay(); this.showPlayerStats()}showPlayerStats() {const playerStatsContainer = document.getElementById('player-stats'); if (playerStatsContainer && this.player) {playerStatsContainer.innerHTML = this.scoreDisplay.createMiniScoreDisplay( this.player.totalScore,this.player.level,this.player.streak )}}startGame(operationType) {if (!this.operations[operationType]) {console.error(`Operation ${operationType}not found`); return}this.gameState.setState({currentScreen: 'game',gameMode: operationType,isGameActive: true }); const modeSelection = document.getElementById('mode-selection'); const gameArea = document.getElementById('game-area'); if (modeSelection) modeSelection.classList.add('hidden'); if (gameArea) gameArea.classList.remove('hidden'); this.soundService.playButton(); this.generateQuestion()}generateQuestion() {const gameMode = this.gameState.getState().gameMode; const difficulty = this.player.settings.difficulty; const operation = this.operations[gameMode]; if (!operation) {console.error(`Operation ${gameMode}not found`); return}const problemData = operation.generateProblem(difficulty); this.currentQuestion = new Question({...problemData,operationType: gameMode,difficulty: difficulty }); this.gameState.setState({currentQuestion: this.currentQuestion }); this.displayQuestion()}displayQuestion() {if (!this.currentQuestion) return; const standardProblem = document.getElementById('standard-problem'); const complexProblem = document.getElementById('complex-problem'); const answerInput = document.getElementById('answer-input'); if (this.currentQuestion.isComplex) {if (standardProblem) standardProblem.classList.add('hidden'); if (complexProblem) complexProblem.classList.remove('hidden'); this.displayComplexQuestion(); return}if (this.currentQuestion.operationType === 'detective' || this.currentQuestion.isDetective) {if (standardProblem) standardProblem.classList.remove('hidden'); if (complexProblem) complexProblem.classList.add('hidden'); this.displayDetectiveQuestion(); return}if (standardProblem) standardProblem.classList.remove('hidden'); if (complexProblem) complexProblem.classList.add('hidden'); const num1Display = document.getElementById('num1-display'); const num2Display = document.getElementById('num2-display'); const operatorDisplay = document.getElementById('operator-display'); const questionMark = document.getElementById('question-mark'); const answerBlocks = document.getElementById('answer-blocks'); if (num1Display) num1Display.textContent = this.currentQuestion.num1; if (num2Display) num2Display.textContent = this.currentQuestion.num2; if (operatorDisplay) {const operation = this.operations[this.currentQuestion.operationType]; operatorDisplay.textContent = operation.symbol; operatorDisplay.className = `operator ${operation.color}`}if (answerInput) {answerInput.value = ''; answerInput.focus()}if (questionMark) questionMark.classList.remove('hidden'); if (answerBlocks) {answerBlocks.classList.add('hidden'); answerBlocks.innerHTML = ''}this.visualizeQuestion()}displayComplexQuestion() {const problemExpression = document.getElementById('problem-expression'); const answerInput = document.getElementById('answer-input'); if (problemExpression && this.currentQuestion.expression) {problemExpression.textContent = this.currentQuestion.expression}if (answerInput) {answerInput.value = ''; answerInput.focus()}console.log('Displaying complex question:',this.currentQuestion.expression)}displayDetectiveQuestion() {const num1Display = document.getElementById('num1-display'); const num2Display = document.getElementById('num2-display'); const operatorDisplay = document.getElementById('operator-display'); const questionMark = document.getElementById('question-mark'); const answerBlocks = document.getElementById('answer-blocks'); const answerInput = document.getElementById('answer-input'); const operation = this.operations[this.currentQuestion.operationType]; if (operation.getRandomCaseTheme) {const theme = operation.getRandomCaseTheme(); console.log('Detective Case:',theme)}if (num1Display) {num1Display.textContent = this.currentQuestion.num1 !== null ? this.currentQuestion.num1 : '?'; num1Display.className = this.currentQuestion.num1 !== null ? 'number-display text-green-500' : 'number-display text-yellow-500'}if (num2Display) {num2Display.textContent = this.currentQuestion.num2 !== null ? this.currentQuestion.num2 : '?'; num2Display.className = this.currentQuestion.num2 !== null ? 'number-display text-yellow-500' : 'number-display text-yellow-500'}if (operatorDisplay) {operatorDisplay.textContent = this.currentQuestion.operation; operatorDisplay.className = 'operator text-yellow-500'}if (questionMark) {questionMark.classList.remove('hidden'); if (this.currentQuestion.missingPosition === 'result') {questionMark.textContent = '?'; questionMark.className = 'number-display text-gray-400'}else {questionMark.textContent = this.currentQuestion.result; questionMark.className = 'number-display text-purple-600'}}if (answerInput) {answerInput.value = ''; answerInput.focus()}if (answerBlocks) {answerBlocks.classList.add('hidden'); answerBlocks.innerHTML = ''}this.visualizeDetectiveQuestion()}async visualizeQuestion() {if (!this.currentQuestion || this.currentQuestion.isComplex) return; const num1Blocks = document.getElementById('num1-blocks'); const num2Blocks = document.getElementById('num2-blocks'); if (num1Blocks && num2Blocks) {await this.blockVisualizer.drawBlocks( this.currentQuestion.num1,num1Blocks,'bg-green-400',true ); setTimeout(async () => {await this.blockVisualizer.drawBlocks( this.currentQuestion.num2,num2Blocks,'bg-yellow-400',true )},300)}}async visualizeDetectiveQuestion() {if (!this.currentQuestion) return; const containers = {num1Container: document.getElementById('num1-blocks'),operatorContainer: document.getElementById('operator-display'),num2Container: document.getElementById('num2-blocks'),equalsContainer: document.querySelector('.number-section .operator'),resultContainer: document.getElementById('answer-blocks') }; if (containers.resultContainer) {containers.resultContainer.classList.remove('hidden')}await this.blockVisualizer.animateDetectiveEquation( this.currentQuestion.equation,containers,this.currentQuestion )}checkAnswer() {if (!this.currentQuestion) return; const answerInput = document.getElementById('answer-input'); if (!answerInput) return; const userAnswer = answerInput.value.trim(); if (!userAnswer) return; const isCorrect = this.currentQuestion.submitAnswer(userAnswer); const points = this.currentQuestion.getPoints() + this.currentQuestion.getDifficultyBonus(); this.player.recordAnswer( this.currentQuestion.operationType,isCorrect,isCorrect ? points : 0 ); if (isCorrect) {if (this.currentQuestion.operationType === 'detective' || this.currentQuestion.isDetective) {this.soundService.playCaseClosed()}else {this.soundService.playCorrect()}this.showAnswerVisualization()}else {this.soundService.playIncorrect()}this.updateScoreDisplay(); this.checkAchievements(); this.saveProgress(); this.showFeedback(isCorrect)}async showAnswerVisualization() {if (!this.currentQuestion) return; if (this.currentQuestion.isComplex) {const problemExpression = document.getElementById('problem-expression'); if (problemExpression) {const fullExpression = `${this.currentQuestion.expression}= ${this.currentQuestion.correctAnswer}`; problemExpression.textContent = fullExpression; problemExpression.classList.add('text-green-600'); setTimeout(() => {problemExpression.classList.remove('text-green-600'); problemExpression.classList.add('text-gray-700')},2000)}return}if (this.currentQuestion.operationType === 'detective' || this.currentQuestion.isDetective) {const containers = {num1Container: document.getElementById('num1-blocks'),num2Container: document.getElementById('num2-blocks'),resultContainer: document.getElementById('answer-blocks') }; const answerInput = document.getElementById('answer-input'); const userAnswer = answerInput ? parseInt(answerInput.value) : this.currentQuestion.correctAnswer; await this.blockVisualizer.revealDetectiveSolution(containers,this.currentQuestion,userAnswer); return}const questionMark = document.getElementById('question-mark'); const answerBlocks = document.getElementById('answer-blocks'); if (questionMark) questionMark.classList.add('hidden'); if (answerBlocks) {answerBlocks.classList.remove('hidden'); await this.blockVisualizer.drawBlocks( this.currentQuestion.correctAnswer,answerBlocks,'bg-blue-400',true )}}showFeedback(isCorrect) {const onNext = () => {this.modalManager.close('feedback'); this.generateQuestion()}; const onExplain = async () => {this.modalManager.showLoadingExplanation(); const operation = this.operations[this.currentQuestion.operationType]; let prompt; if (this.currentQuestion.isComplex) {prompt = operation.getExplanationPrompt(this.currentQuestion.expression)}else {prompt = operation.getExplanationPrompt( this.currentQuestion.num1,this.currentQuestion.num2 )}try {const explanation = await this.apiService.generateExplanation( prompt,this.currentQuestion.operationType ); this.modalManager.showExplanation(explanation); this.currentQuestion.requestExplanation()}catch (error) {console.error('Error getting explanation:',error); this.modalManager.showExplanation('Sorry,I had trouble getting an explanation. Please try the next question!')}}; this.modalManager.showFeedbackModal( isCorrect,this.currentQuestion,onNext,!isCorrect ? onExplain : null )}checkAchievements() {const unlockedAchievements = []; this.achievements.forEach((achievement,id) => {if (!this.player.hasAchievement(id) && achievement.isUnlocked(this.player)) {this.player.addAchievement(id); unlockedAchievements.push(achievement); this.eventBus.emit('achievementUnlocked',{achievement })}}); return unlockedAchievements}handleAchievementUnlocked(data) {const {achievement }= data; this.soundService.playAchievement(); this.scoreDisplay.animateAchievementScore(achievement.points); this.player.addScore(achievement.points); this.updateScoreDisplay(); setTimeout(() => {this.showAchievementNotification(achievement)},500)}showAchievementNotification(achievement) {const modal = this.modalManager.create('achievement-notification',{title: 'üèÜ Achievement Unlocked!',content: ` <div class="text-center"> <div class="text-4xl mb-4">${this.getAchievementIcon(achievement.medal)}</div> <h3 class="text-2xl font-bold mb-2">${achievement.name}</h3> <p class="text-gray-600 mb-4">${achievement.description}</p> <p class="text-lg font-bold text-blue-600">+${achievement.points}bonus points!</p> </div> `,type: 'success',buttons: [ {text: 'Awesome!',type: 'success',action: 'close' }] }); this.modalManager.show('achievement-notification')}getAchievementIcon(medal) {const icons = {bronze: 'ü•â',silver: 'ü•à',gold: 'ü•á',platinum: 'üèÜ' }; return icons[medal] || 'üèÜ'}updateScoreDisplay() {if (!this.player) return; this.scoreDisplay.update('score',this.player.totalScore); const levelDisplay = document.getElementById('level-display'); if (levelDisplay) {this.scoreDisplay.update('level-display',this.player.level)}const streakDisplay = document.getElementById('streak-display'); if (streakDisplay) {this.scoreDisplay.update('streak-display',this.player.streak)}}saveProgress() {if (this.player) {this.storageService.savePlayerData(this.player.toJSON()); if (this.currentQuestion) {this.storageService.saveGameHistory({timestamp: new Date().toISOString(),question: this.currentQuestion.toJSON(),playerScore: this.player.totalScore,playerLevel: this.player.level })}}}handleStateChange(data) {const {changes }= data; if (changes.currentScreen) {this.eventBus.emit('screenChanged',{from: data.oldState.currentScreen,to: data.newState.currentScreen })}}handleVisualizationComplete(data) {console.log(`Visualization complete for ${data.operation}: ${data.result}`)}handleModalButtonClick(data) {console.log(`Modal button clicked: ${data.action}in ${data.modalId}`)}handleInitializationError(error) {console.error('Game initialization failed:',error); const errorModal = this.modalManager.create('initialization-error',{title: 'Initialization Error',content: ` <p class="mb-4">There was a problem starting the game:</p> <p class="text-sm text-gray-600 mb-4">${error.message}</p> <p>Please refresh the page to try again.</p> `,type: 'error',buttons: [ {text: 'Refresh Page',type: 'primary',action: 'refresh' }],closable: false }); this.eventBus.on('modalButtonClick',(data) => {if (data.modalId === 'initialization-error' && data.action === 'refresh') {window.location.reload()}}); this.modalManager.show('initialization-error')}setApiKey(apiKey) {this.apiService.setApiKey(apiKey)}setSoundEnabled(enabled) {this.soundService.setEnabled(enabled); this.player.updateSettings({soundEnabled: enabled }); this.saveProgress()}setMusicEnabled(enabled) {this.soundService.setMusicEnabled(enabled); this.player.updateSettings({musicEnabled: enabled }); this.saveProgress()}setDifficulty(difficulty) {this.player.updateSettings({difficulty }); this.saveProgress()}getGameStatus() {return {initialized: this.isInitialized,currentScreen: this.gameState.getState().currentScreen,gameMode: this.gameState.getState().gameMode,isGameActive: this.gameState.getState().isGameActive,player: this.player ? {score: this.player.totalScore,level: this.player.level,streak: this.player.streak }: null,services: {storage: this.storageService.getStorageInfo(),api: this.apiService.getStatus(),sound: this.soundService.getStatus() }}}destroy() {this.eventBus.clear(); this.modalManager.closeAll(); this.scoreDisplay.resetAll(); this.isInitialized = false}}return Game;
    };

    __modules__['core/GameState'] = function(__require__, module, exports) {
        class GameState {constructor(eventBus) {this.eventBus = eventBus; this.state = {currentScreen: 'menu',player: null,currentQuestion: null,gameMode: null,difficulty: 'medium',settings: {soundEnabled: true,animationSpeed: 'normal' },isGameActive: false,level: 1 }; this.listeners = new Map()}getState() {return {...this.state }}setState(updates) {const oldState = {...this.state }; this.state = {...this.state,...updates }; this.notifyListeners(oldState,this.state); this.eventBus.emit('stateChanged',{oldState,newState: this.state,changes: updates })}subscribe(key,callback) {if (!this.listeners.has(key)) {this.listeners.set(key,[])}this.listeners.get(key).push(callback); return () => this.unsubscribe(key,callback)}unsubscribe(key,callback) {if (this.listeners.has(key)) {const callbacks = this.listeners.get(key); const index = callbacks.indexOf(callback); if (index > -1) {callbacks.splice(index,1)}}}notifyListeners(oldState,newState) {this.listeners.forEach((callbacks,key) => {const oldValue = this.getNestedValue(oldState,key); const newValue = this.getNestedValue(newState,key); if (oldValue !== newValue) {callbacks.forEach(callback => {try {callback(newValue,oldValue)}catch (error) {console.error(`Error in state listener for ${key}:`,error)}})}})}getNestedValue(obj,path) {return path.split('.').reduce((current,key) => current?.[key],obj)}reset() {const defaultState = {currentScreen: 'menu',player: null,currentQuestion: null,gameMode: null,difficulty: this.state.difficulty,settings: this.state.settings,isGameActive: false,level: 1 }; this.setState(defaultState)}}return GameState;
    };

    __modules__['models/Achievement'] = function(__require__, module, exports) {
        class Achievement {constructor(data) {this.id = data.id; this.name = data.name; this.description = data.description; this.category = data.category; this.requirement = data.requirement; this.points = data.points; this.medal = data.medal; this.icon = data.icon || null; this.isHidden = data.isHidden || false; this.unlockedAt = data.unlockedAt || null}checkProgress(player) {const stats = player.operationStats[this.category]; if (!stats) return 0; switch (this.category) {case 'addition': case 'subtraction': case 'multiplication': case 'division': case 'supermode': return stats.correctAnswers; case 'overall': return player.totalScore; case 'streak': return player.bestStreak; default: return 0}}isUnlocked(player) {return this.checkProgress(player) >= this.requirement}getProgressPercentage(player) {const progress = this.checkProgress(player); return Math.min(Math.round((progress / this.requirement) * 100),100)}unlock() {this.unlockedAt = new Date().toISOString(); return this}getMedalColor() {const colors = {bronze: '#CD7F32',silver: '#C0C0C0',gold: '#FFD700',platinum: '#E5E4E2' }; return colors[this.medal] || colors.bronze}toJSON() {return {id: this.id,name: this.name,description: this.description,category: this.category,requirement: this.requirement,points: this.points,medal: this.medal,icon: this.icon,isHidden: this.isHidden,unlockedAt: this.unlockedAt }}static fromJSON(data) {return new Achievement(data)}}const ACHIEVEMENT_DEFINITIONS = {addition: [ {id: 'add_bronze',name: 'Addition Apprentice',description: 'Solve 50 addition problems correctly',requirement: 50,points: 50,medal: 'bronze',category: 'addition' },{id: 'add_silver',name: 'Addition Expert',description: 'Solve 200 addition problems correctly',requirement: 200,points: 200,medal: 'silver',category: 'addition' },{id: 'add_gold',name: 'Addition Master',description: 'Solve 500 addition problems correctly',requirement: 500,points: 500,medal: 'gold',category: 'addition' }],subtraction: [ {id: 'sub_bronze',name: 'Subtraction Starter',description: 'Solve 50 subtraction problems correctly',requirement: 50,points: 50,medal: 'bronze',category: 'subtraction' },{id: 'sub_silver',name: 'Subtraction Specialist',description: 'Solve 200 subtraction problems correctly',requirement: 200,points: 200,medal: 'silver',category: 'subtraction' },{id: 'sub_gold',name: 'Subtraction Champion',description: 'Solve 500 subtraction problems correctly',requirement: 500,points: 500,medal: 'gold',category: 'subtraction' }],multiplication: [ {id: 'mul_bronze',name: 'Multiplication Rookie',description: 'Solve 50 multiplication problems correctly',requirement: 50,points: 50,medal: 'bronze',category: 'multiplication' },{id: 'mul_silver',name: 'Multiplication Pro',description: 'Solve 200 multiplication problems correctly',requirement: 200,points: 200,medal: 'silver',category: 'multiplication' },{id: 'mul_gold',name: 'Multiplication Wizard',description: 'Solve 500 multiplication problems correctly',requirement: 500,points: 500,medal: 'gold',category: 'multiplication' }],division: [ {id: 'div_bronze',name: 'Division Beginner',description: 'Solve 50 division problems correctly',requirement: 50,points: 50,medal: 'bronze',category: 'division' },{id: 'div_silver',name: 'Division Expert',description: 'Solve 200 division problems correctly',requirement: 200,points: 200,medal: 'silver',category: 'division' },{id: 'div_gold',name: 'Division Master',description: 'Solve 500 division problems correctly',requirement: 500,points: 500,medal: 'gold',category: 'division' }],special: [ {id: 'super_bronze',name: 'Super Solver',description: 'Solve 25 Super Mode problems correctly',requirement: 25,points: 100,medal: 'bronze',category: 'supermode' },{id: 'super_silver',name: 'Super Expert',description: 'Solve 100 Super Mode problems correctly',requirement: 100,points: 300,medal: 'silver',category: 'supermode' },{id: 'super_gold',name: 'Super Champion',description: 'Solve 250 Super Mode problems correctly',requirement: 250,points: 750,medal: 'gold',category: 'supermode' },{id: 'streak_10',name: 'Perfect 10',description: 'Get 10 problems correct in a row',requirement: 10,points: 50,medal: 'bronze',category: 'streak' },{id: 'streak_25',name: 'Streak Master',description: 'Get 25 problems correct in a row',requirement: 25,points: 150,medal: 'silver',category: 'streak' },{id: 'streak_50',name: 'Unstoppable',description: 'Get 50 problems correct in a row',requirement: 50,points: 300,medal: 'gold',category: 'streak' }] }; return {Achievement,ACHIEVEMENT_DEFINITIONS };;
    };

    __modules__['models/Player'] = function(__require__, module, exports) {
        class Player {constructor(data = {}) {this.id = data.id || this.generateId(); this.totalScore = data.totalScore || 0; this.operationStats = data.operationStats || {addition: {score: 0,questionsAnswered: 0,correctAnswers: 0 },subtraction: {score: 0,questionsAnswered: 0,correctAnswers: 0 },multiplication: {score: 0,questionsAnswered: 0,correctAnswers: 0 },division: {score: 0,questionsAnswered: 0,correctAnswers: 0 },supermode: {score: 0,questionsAnswered: 0,correctAnswers: 0 },detective: {score: 0,questionsAnswered: 0,correctAnswers: 0 }}; this.achievements = data.achievements || []; this.settings = data.settings || {difficulty: 'medium',soundEnabled: true,musicEnabled: true,animationSpeed: 'normal' }; this.createdAt = data.createdAt || new Date().toISOString(); this.lastPlayed = data.lastPlayed || new Date().toISOString(); this.level = data.level || 1; this.streak = data.streak || 0; this.bestStreak = data.bestStreak || 0}generateId() {return 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2,9)}recordAnswer(operation,isCorrect,points = 10) {if (!this.operationStats[operation]) {this.operationStats[operation] = {score: 0,questionsAnswered: 0,correctAnswers: 0 }}this.operationStats[operation].questionsAnswered++; if (isCorrect) {this.operationStats[operation].correctAnswers++; this.operationStats[operation].score += points; this.totalScore += points; this.streak++; if (this.streak > this.bestStreak) {this.bestStreak = this.streak}}else {this.streak = 0}this.lastPlayed = new Date().toISOString(); if (this.totalScore >= this.level * 50) {this.level++}}getAccuracy(operation) {const stats = this.operationStats[operation]; if (!stats || stats.questionsAnswered === 0) return 0; return Math.round((stats.correctAnswers / stats.questionsAnswered) * 100 * 100) / 100}getOverallAccuracy() {let totalCorrect = 0; let totalAnswered = 0; Object.values(this.operationStats).forEach(stats => {totalCorrect += stats.correctAnswers; totalAnswered += stats.questionsAnswered}); if (totalAnswered === 0) return 0; return Math.round((totalCorrect / totalAnswered) * 100 * 100) / 100}addScore(points) {if (points < 0) {throw new Error('Score cannot be negative')}this.totalScore += points}addAchievement(achievementId) {if (!this.achievements.includes(achievementId)) {this.achievements.push(achievementId); return true}return false}hasAchievement(achievementId) {return this.achievements.includes(achievementId)}updateSettings(newSettings) {this.settings = {...this.settings,...newSettings }}toJSON() {return {id: this.id,totalScore: this.totalScore,operationStats: this.operationStats,achievements: this.achievements,settings: this.settings,createdAt: this.createdAt,lastPlayed: this.lastPlayed,level: this.level,streak: this.streak,bestStreak: this.bestStreak }}static fromJSON(data) {return new Player(data)}}return Player;
    };

    __modules__['models/Question'] = function(__require__, module, exports) {
        class Question {constructor(data) {this.num1 = data.num1; this.num2 = data.num2; this.correctAnswer = data.correctAnswer; this.operation = data.operation; this.operationType = data.operationType; this.difficulty = data.difficulty; this.isComplex = data.isComplex || false; this.equation = data.equation || null; this.expression = data.expression || null; this.timeGenerated = new Date().toISOString(); this.timeAnswered = null; this.userAnswer = null; this.isCorrect = null; this.hintsUsed = 0; this.explanationRequested = false}submitAnswer(answer,timeAnswered = new Date().toISOString()) {this.userAnswer = parseInt(answer); this.timeAnswered = timeAnswered; this.isCorrect = this.userAnswer === this.correctAnswer; return this.isCorrect}getResponseTime() {if (!this.timeAnswered) return null; const start = new Date(this.timeGenerated); const end = new Date(this.timeAnswered); return Math.round((end - start) / 1000)}useHint() {this.hintsUsed++}requestExplanation() {this.explanationRequested = true}getDisplayText() {if (this.isComplex && this.expression) {return `${this.expression}= ?`}return `${this.num1}${this.operation}${this.num2}= ?`}getPoints() {let basePoints = 10; if (this.operationType === 'supermode') {basePoints *= 2}const responseTime = this.getResponseTime(); if (responseTime && responseTime < 5) {basePoints += 5}basePoints -= this.hintsUsed * 2; return Math.max(basePoints,1)}getDifficultyBonus() {const bonuses = {easy: 0,medium: 2,hard: 5 }; return bonuses[this.difficulty] || 0}toJSON() {return {num1: this.num1,num2: this.num2,correctAnswer: this.correctAnswer,operation: this.operation,operationType: this.operationType,difficulty: this.difficulty,isComplex: this.isComplex,equation: this.equation,expression: this.expression,timeGenerated: this.timeGenerated,timeAnswered: this.timeAnswered,userAnswer: this.userAnswer,isCorrect: this.isCorrect,hintsUsed: this.hintsUsed,explanationRequested: this.explanationRequested }}}return Question;
    };

    __modules__['operations/Addition'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class Addition extends BaseOperation {constructor() {super('addition','+','text-green-500')}generate(settings) {const num1 = Math.floor(Math.random() * settings.max) + settings.min; const num2 = Math.floor(Math.random() * settings.max) + settings.min; const correctAnswer = num1 + num2; return {num1,num2,correctAnswer,operation: this.symbol }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 10 },medium: {min: 1,max: 25 },hard: {min: 10,max: 99 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Count all the blocks together to find the sum!'}getExplanationPrompt(num1,num2) {return `Explain to a 7-year-old how to solve ${num1}+ ${num2}step-by-step. Talk about counting blocks or using fingers. Be very simple,encouraging,and use short sentences. Break it down into easy steps.`}}return Addition;
    };

    __modules__['operations/BaseOperation'] = function(__require__, module, exports) {
        class BaseOperation {constructor(name,symbol,color) {this.name = name; this.symbol = symbol; this.color = color}generate(difficulty) {throw new Error('generate() must be implemented by subclass')}validate(answer,correctAnswer) {return parseInt(answer) === parseInt(correctAnswer)}getExplanationPrompt(num1,num2,operation) {return `Explain to a 7-year-old how to solve ${num1}${operation}${num2}step-by-step. Be very simple,encouraging,and use short sentences. Break it down into easy steps. Don't mention the wrong answer,just explain how to get the correct one.`}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 10 },medium: {min: 1,max: 25 },hard: {min: 10,max: 99 }}; return settings[difficulty] || settings.medium}generateProblem(difficulty) {const settings = this.getDifficultySettings(difficulty); return this.generate(settings)}getVisualHint() {return `Use blocks to help visualize this ${this.name}problem.`}}return BaseOperation;
    };

    __modules__['operations/DetectiveOperation'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class DetectiveOperation extends BaseOperation {constructor() {super('detective','üïµÔ∏è','text-yellow-500')}generate(settings) {const operations = ['addition','subtraction']; const operationType = operations[Math.floor(Math.random() * operations.length)]; let num1,num2,correctAnswer,equation,visualHint; let missingPosition,result; if (operationType === 'addition') {const operand1 = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min; const operand2 = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min; result = operand1 + operand2; const missingPart = Math.floor(Math.random() * 3); switch (missingPart) {case 0: num1 = null; num2 = operand2; correctAnswer = operand1; equation = `? + ${num2}= ${result}`; missingPosition = 'first'; visualHint = `What number plus ${num2}equals ${result}?`; break; case 1: num1 = operand1; num2 = null; correctAnswer = operand2; equation = `${num1}+ ? = ${result}`; missingPosition = 'second'; visualHint = `What number added to ${num1}makes ${result}?`; break; default: num1 = operand1; num2 = operand2; correctAnswer = result; equation = `${num1}+ ${num2}= ?`; missingPosition = 'result'; visualHint = `What is ${num1}plus ${num2}?`; break}}else {const minuend = Math.floor(Math.random() * (settings.max - settings.min + 1)) + settings.min + 5; const subtrahend = Math.floor(Math.random() * Math.min(minuend - 1,settings.max)) + 1; result = minuend - subtrahend; const missingPart = Math.floor(Math.random() * 3); switch (missingPart) {case 0: num1 = null; num2 = subtrahend; correctAnswer = minuend; equation = `? - ${num2}= ${result}`; missingPosition = 'first'; visualHint = `What number minus ${num2}equals ${result}?`; break; case 1: num1 = minuend; num2 = null; correctAnswer = subtrahend; equation = `${num1}- ? = ${result}`; missingPosition = 'second'; visualHint = `What number subtracted from ${num1}leaves ${result}?`; break; default: num1 = minuend; num2 = subtrahend; correctAnswer = result; equation = `${num1}- ${num2}= ?`; missingPosition = 'result'; visualHint = `What is ${num1}minus ${num2}?`; break}}return {num1,num2,correctAnswer,operation: operationType === 'addition' ? '+' : '-',equation,expression: equation,result: result,missingPosition,visualHint,operationType: 'detective',isDetective: true }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 20 },medium: {min: 5,max: 50 },hard: {min: 10,max: 99 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Look for clues in the blocks to solve the mystery!'}getExplanationPrompt(equation,visualHint) {return `Explain to a 7-year-old detective how to solve this mystery equation: ${equation}. Help them understand: ${visualHint}. Use simple words and think step-by-step like a detective finding clues.`}getScoreMultiplier() {return 1.5}getCaseThemes() {return [ "üïµÔ∏è The Case of the Missing Number","üîç Detective's Number Mystery","üéØ The Great Math Investigation","üîé Solving the Number Puzzle","üïµÔ∏è‚Äç‚ôÄÔ∏è Detective Mode: Find the Clue!" ]}getRandomCaseTheme() {const themes = this.getCaseThemes(); return themes[Math.floor(Math.random() * themes.length)]}getProblemType(missingPosition,operation) {const types = {addition: {first: 'missing_addend_1',second: 'missing_addend_2',result: 'missing_sum' },subtraction: {first: 'missing_minuend',second: 'missing_subtrahend',result: 'missing_difference' }}; return types[operation]?.[missingPosition] || 'unknown'}}return DetectiveOperation;
    };

    __modules__['operations/Division'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class Division extends BaseOperation {constructor() {super('division','√∑','text-purple-500')}generate(settings) {const maxQuotient = Math.min(settings.maxResult || 20,20); const maxDivisor = Math.min(settings.max,12); const quotient = Math.floor(Math.random() * maxQuotient) + 1; const divisor = Math.floor(Math.random() * maxDivisor) + 1; const dividend = divisor * quotient; return {num1: dividend,num2: divisor,correctAnswer: quotient,operation: this.symbol }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 5,maxResult: 10 },medium: {min: 1,max: 10,maxResult: 50 },hard: {min: 2,max: 15,maxResult: 100 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Share the blocks equally into groups!'}getExplanationPrompt(num1,num2) {return `Explain to a 7-year-old how to solve ${num1}√∑ ${num2}step-by-step. Talk about sharing blocks equally into groups or repeated subtraction. Be very simple,encouraging,and use short sentences. Break it down into easy steps.`}getVisualMode() {return 'grouping'}}return Division;
    };

    __modules__['operations/Multiplication'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class Multiplication extends BaseOperation {constructor() {super('multiplication','√ó','text-red-500')}generate(settings) {const maxFactor = Math.min(settings.max,12); const num1 = Math.floor(Math.random() * maxFactor) + 1; const num2 = Math.floor(Math.random() * maxFactor) + 1; const correctAnswer = num1 * num2; return {num1,num2,correctAnswer,operation: this.symbol }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 5 },medium: {min: 1,max: 10 },hard: {min: 5,max: 15 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Think of groups of blocks - how many blocks in total?'}getExplanationPrompt(num1,num2) {return `Explain to a 7-year-old how to solve ${num1}√ó ${num2}step-by-step. Talk about making groups of blocks or repeated addition. Be very simple,encouraging,and use short sentences. Break it down into easy steps.`}}return Multiplication;
    };

    __modules__['operations/Subtraction'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class Subtraction extends BaseOperation {constructor() {super('subtraction','-','text-yellow-500')}generate(settings) {const a = Math.floor(Math.random() * settings.max) + settings.min; const b = Math.floor(Math.random() * settings.max) + settings.min; const num1 = Math.max(a,b); const num2 = Math.min(a,b); const correctAnswer = num1 - num2; return {num1,num2,correctAnswer,operation: this.symbol }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 10 },medium: {min: 1,max: 25 },hard: {min: 10,max: 99 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Take away blocks from the first number to find the difference!'}getExplanationPrompt(num1,num2) {return `Explain to a 7-year-old how to solve ${num1}- ${num2}step-by-step. Talk about taking away blocks or counting backwards. Be very simple,encouraging,and use short sentences. Break it down into easy steps.`}}return Subtraction;
    };

    __modules__['operations/SuperMode'] = function(__require__, module, exports) {
        const BaseOperation = __modules__['operations/BaseOperation.js'] || {}; class SuperMode extends BaseOperation {constructor() {super('supermode','¬±','text-gradient')}generate(settings) {const termCount = Math.floor(Math.random() * 3) + 2; const startNumber = Math.floor(Math.random() * 20) + 10; let equation = [startNumber]; let result = startNumber; let expressionParts = [startNumber.toString()]; for (let i = 1; i < termCount; i++) {const operation = Math.random() > 0.5 ? '+' : '-'; const number = Math.floor(Math.random() * 15) + 1; equation.push({operation,number }); expressionParts.push(` ${operation}${number}`); if (operation === '+') {result += number}else {result -= number; if (result < 0) {result += number * 2; equation[equation.length - 1].operation = '+'; expressionParts[expressionParts.length - 1] = ` + ${number}`}}}return {num1: null,num2: null,correctAnswer: result,operation: this.symbol,equation: equation,expression: expressionParts.join(''),isComplex: true }}getDifficultySettings(difficulty) {const settings = {easy: {min: 1,max: 10,terms: 2 },medium: {min: 1,max: 15,terms: 3 },hard: {min: 5,max: 25,terms: 4 }}; return settings[difficulty] || settings.medium}getVisualHint() {return 'Work through each operation step by step!'}getExplanationPrompt(expression) {return `Explain to a 7-year-old how to solve this step by step: ${expression}. Break it down into simple steps,working from left to right. Be very encouraging and use short sentences.`}getScoreMultiplier() {return 2}}return SuperMode;
    };

    __modules__['services/APIService'] = function(__require__, module, exports) {
        class APIService {constructor() {this.baseUrl = 'https: this.apiKey = ''; this.timeout = 10000; this.maxRetries = 3; this.cache = new Map(); this.rateLimit = {requests: 0,resetTime: Date.now() + 60000 }}setApiKey(apiKey) {this.apiKey = apiKey}async generateExplanation(prompt,operation = null) {if (!this.apiKey) {return this.getFallbackExplanation(operation)}if (this.isRateLimited()) {console.warn('Rate limit exceeded,using fallback'); return this.getFallbackExplanation(operation)}const cacheKey = this.getCacheKey(prompt); if (this.cache.has(cacheKey)) {return this.cache.get(cacheKey)}let attempt = 0; while (attempt < this.maxRetries) {try {const response = await this.makeRequest(prompt); const explanation = this.parseResponse(response); this.cache.set(cacheKey,explanation); this.updateRateLimit(); return explanation}catch (error) {attempt++; console.warn(`API request attempt ${attempt}failed:`,error.message); if (attempt >= this.maxRetries) {return this.getFallbackExplanation(operation)}await this.delay(Math.pow(2,attempt) * 1000)}}}async makeRequest(prompt) {const controller = new AbortController(); const timeoutId = setTimeout(() => controller.abort(),this.timeout); try {const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`,{method: 'POST',headers: {'Content-Type': 'application/json' },body: JSON.stringify({contents: [{parts: [{text: prompt }] }],generationConfig: {temperature: 0.7,maxOutputTokens: 200 }}),signal: controller.signal }); clearTimeout(timeoutId); if (!response.ok) {throw new Error(`API request failed with status ${response.status}`)}return await response.json()}catch (error) {clearTimeout(timeoutId); throw error}}parseResponse(response) {try {if (response.candidates && response.candidates.length > 0 && response.candidates[0].content && response.candidates[0].content.parts && response.candidates[0].content.parts.length > 0) {let text = response.candidates[0].content.parts[0].text; return this.formatExplanation(text)}}catch (error) {console.error('Error parsing API response:',error)}return 'Sorry,I had trouble thinking of an explanation. Please try the next question!'}formatExplanation(text) {return text .replace(/\n/g,'<br>') .replace(/\*\*(.*?)\*\*/g,'<strong>$1</strong>') .replace(/\*(.*?)\*/g,'<em>$1</em>') .trim()}getFallbackExplanation(operation) {const fallbacks = {addition: "Let's add step by step! Count all the blocks together. Start with the first number,then count up by the second number. For example,if you have 5 + 3,start at 5 and count: 6,7,8. The answer is 8!",subtraction: "Let's subtract step by step! Start with the bigger number and take away the smaller number. You can use your blocks - start with the first pile and remove the second number of blocks. Count what's left!",multiplication: "Let's multiply step by step! Multiplication is like making groups. If you have 3 √ó 4,make 3 groups with 4 blocks each,or 4 groups with 3 blocks each. Then count all the blocks together!",division: "Let's divide step by step! Division is like sharing equally. If you have 12 √∑ 3,take 12 blocks and share them into 3 equal groups. Count how many blocks are in each group - that's your answer!",supermode: "Let's solve this step by step! Work from left to right. Do each operation one at a time. Take your time and double-check each step!" }; return fallbacks[operation] || "Break the problem into smaller steps. Take your time and think through each part. You can do this!"}getCacheKey(prompt) {return btoa(prompt).replace(/[^a-zA-Z0-9]/g,'').substring(0,32)}isRateLimited() {if (Date.now() > this.rateLimit.resetTime) {this.rateLimit.requests = 0; this.rateLimit.resetTime = Date.now() + 60000}return this.rateLimit.requests >= 10}updateRateLimit() {this.rateLimit.requests++}delay(ms) {return new Promise(resolve => setTimeout(resolve,ms))}clearCache() {this.cache.clear()}getStatus() {return {hasApiKey: !!this.apiKey,cacheSize: this.cache.size,rateLimit: {...this.rateLimit },isRateLimited: this.isRateLimited() }}}return APIService;
    };

    __modules__['services/SoundService'] = function(__require__, module, exports) {
        class SoundService {constructor() {this.enabled = true; this.volume = 0.7; this.sounds = new Map(); this.audioContext = null; this.backgroundMusic = null; this.musicEnabled = true; this.musicVolume = 0.3; this.fadeInDuration = 1000; this.fadeOutDuration = 500; this.initAudioContext(); this.preloadSounds()}initAudioContext() {try {window.AudioContext = window.AudioContext || window.webkitAudioContext; this.audioContext = new AudioContext()}catch (error) {console.warn('Web Audio API not supported,falling back to HTML5 audio'); this.audioContext = null}}preloadSounds() {const soundFiles = {correct: 'assets/sounds/correct.mp3',incorrect: 'assets/sounds/incorrect.mp3',achievement: 'assets/sounds/achievement.mp3',caseClosed: 'assets/sounds/case-closed.mp3',click: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhCkGo',button: 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhCkGo' }; Object.entries(soundFiles).forEach(([name,url]) => {this.loadSound(name,url)}); this.loadBackgroundMusic('assets/sounds/bg-music.mp3')}async loadSound(name,url) {try {if (url.startsWith('data:')) {const audio = new Audio(url); this.sounds.set(name,{audio,type: 'data' }); return}const response = await fetch(url); if (!response.ok) {this.createFallbackSound(name); return}if (this.audioContext) {const arrayBuffer = await response.arrayBuffer(); const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer); this.sounds.set(name,{buffer: audioBuffer,type: 'web-audio' })}else {const audio = new Audio(url); this.sounds.set(name,{audio,type: 'html5' })}}catch (error) {console.warn(`Failed to load sound ${name}:`,error); this.createFallbackSound(name)}}createFallbackSound(name) {const frequencies = {correct: [523.25,659.25,783.99],incorrect: [220,185,146.83],achievement: [523.25,659.25,783.99,1046.50],click: [800],button: [600] }; const freq = frequencies[name] || [440]; this.sounds.set(name,{frequencies: freq,type: 'generated' })}play(soundName,options = {}) {if (!this.enabled) return; const sound = this.sounds.get(soundName); if (!sound) {console.warn(`Sound ${soundName}not found`); return}const volume = options.volume !== undefined ? options.volume : this.volume; const playbackRate = options.playbackRate || 1; try {switch (sound.type) {case 'web-audio': this.playWebAudio(sound.buffer,volume,playbackRate); break; case 'html5': case 'data': this.playHTML5Audio(sound.audio,volume,playbackRate); break; case 'generated': this.playGeneratedSound(sound.frequencies,volume); break}}catch (error) {console.warn(`Error playing sound ${soundName}:`,error)}}playWebAudio(buffer,volume,playbackRate) {if (!this.audioContext) return; const source = this.audioContext.createBufferSource(); const gainNode = this.audioContext.createGain(); source.buffer = buffer; source.playbackRate.value = playbackRate; gainNode.gain.value = volume; source.connect(gainNode); gainNode.connect(this.audioContext.destination); source.start()}playHTML5Audio(audio,volume,playbackRate) {const audioClone = audio.cloneNode(); audioClone.volume = volume; audioClone.playbackRate = playbackRate; const playPromise = audioClone.play(); if (playPromise !== undefined) {playPromise.catch(error => {console.warn('HTML5 audio play failed:',error)})}}playGeneratedSound(frequencies,volume) {if (!this.audioContext) return; const oscillator = this.audioContext.createOscillator(); const gainNode = this.audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(this.audioContext.destination); oscillator.frequency.setValueAtTime(frequencies[0],this.audioContext.currentTime); if (frequencies.length > 1) {const noteDuration = 0.15; frequencies.forEach((freq,index) => {const time = this.audioContext.currentTime + (index * noteDuration); oscillator.frequency.setValueAtTime(freq,time)})}gainNode.gain.setValueAtTime(0,this.audioContext.currentTime); gainNode.gain.linearRampToValueAtTime(volume,this.audioContext.currentTime + 0.01); gainNode.gain.exponentialRampToValueAtTime(0.01,this.audioContext.currentTime + 0.5); oscillator.start(this.audioContext.currentTime); oscillator.stop(this.audioContext.currentTime + 0.5)}playCorrect() {this.play('correct')}playIncorrect() {this.play('incorrect')}playAchievement() {this.play('achievement')}playClick() {this.play('click',{volume: 0.3 })}playButton() {this.play('button',{volume: 0.5 })}playCaseClosed() {this.play('caseClosed')}setEnabled(enabled) {this.enabled = enabled}isEnabled() {return this.enabled}setVolume(volume) {this.volume = Math.max(0,Math.min(1,volume))}getVolume() {return this.volume}resumeAudioContext() {if (this.audioContext && this.audioContext.state === 'suspended') {this.audioContext.resume()}}async loadBackgroundMusic(url) {try {const response = await fetch(url); if (!response.ok) {console.warn('Background music file not found,creating fallback'); this.createFallbackMusic(); return}const audio = new Audio(url); audio.loop = true; audio.volume = 0; audio.preload = 'auto'; this.backgroundMusic = audio; audio.addEventListener('error',() => {console.warn('Error loading background music,creating fallback'); this.createFallbackMusic()})}catch (error) {console.warn('Failed to load background music:',error); this.createFallbackMusic()}}createFallbackMusic() {if (!this.audioContext) return; this.backgroundMusic = {isPlaying: false,oscillator: null,gainNode: null,type: 'generated' }}async startBackgroundMusic() {if (!this.musicEnabled || !this.backgroundMusic) return; try {if (this.backgroundMusic.type === 'generated') {this.startGeneratedMusic()}else {await this.startAudioMusic()}}catch (error) {console.warn('Error starting background music:',error)}}async startAudioMusic() {if (!this.backgroundMusic || this.backgroundMusic.type === 'generated') return; try {this.backgroundMusic.currentTime = 0; const playPromise = this.backgroundMusic.play(); if (playPromise !== undefined) {await playPromise; this.fadeInMusic()}}catch (error) {console.warn('Error starting audio music:',error)}}startGeneratedMusic() {if (!this.audioContext || !this.backgroundMusic || this.backgroundMusic.isPlaying) return; const oscillator = this.audioContext.createOscillator(); const gainNode = this.audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(this.audioContext.destination); oscillator.frequency.setValueAtTime(261.63,this.audioContext.currentTime); oscillator.type = 'sine'; gainNode.gain.setValueAtTime(0,this.audioContext.currentTime); gainNode.gain.linearRampToValueAtTime(this.musicVolume * 0.3,this.audioContext.currentTime + 1); oscillator.start(); this.backgroundMusic.oscillator = oscillator; this.backgroundMusic.gainNode = gainNode; this.backgroundMusic.isPlaying = true}stopBackgroundMusic() {if (!this.backgroundMusic) return; try {if (this.backgroundMusic.type === 'generated') {this.stopGeneratedMusic()}else {this.stopAudioMusic()}}catch (error) {console.warn('Error stopping background music:',error)}}stopAudioMusic() {if (!this.backgroundMusic || this.backgroundMusic.type === 'generated') return; this.fadeOutMusic(() => {this.backgroundMusic.pause(); this.backgroundMusic.currentTime = 0})}stopGeneratedMusic() {if (!this.backgroundMusic || !this.backgroundMusic.isPlaying) return; if (this.backgroundMusic.gainNode) {this.backgroundMusic.gainNode.gain.linearRampToValueAtTime(0,this.audioContext.currentTime + 0.5)}if (this.backgroundMusic.oscillator) {setTimeout(() => {this.backgroundMusic.oscillator.stop(); this.backgroundMusic.isPlaying = false},500)}}pauseBackgroundMusic() {if (!this.backgroundMusic) return; if (this.backgroundMusic.type === 'generated') {this.stopGeneratedMusic()}else if (!this.backgroundMusic.paused) {this.fadeOutMusic(() => {this.backgroundMusic.pause()})}}resumeBackgroundMusic() {if (!this.backgroundMusic || !this.musicEnabled) return; if (this.backgroundMusic.type === 'generated') {this.startGeneratedMusic()}else if (this.backgroundMusic.paused) {this.backgroundMusic.play().then(() => {this.fadeInMusic()}).catch(console.warn)}}fadeInMusic() {if (!this.backgroundMusic || this.backgroundMusic.type === 'generated') return; this.backgroundMusic.volume = 0; const fadeIn = () => {if (this.backgroundMusic.volume < this.musicVolume) {this.backgroundMusic.volume = Math.min(this.backgroundMusic.volume + 0.02,this.musicVolume); setTimeout(fadeIn,50)}}; fadeIn()}fadeOutMusic(callback) {if (!this.backgroundMusic || this.backgroundMusic.type === 'generated') {if (callback) callback(); return}const fadeOut = () => {if (this.backgroundMusic.volume > 0) {this.backgroundMusic.volume = Math.max(this.backgroundMusic.volume - 0.04,0); setTimeout(fadeOut,25)}else if (callback) {callback()}}; fadeOut()}setMusicEnabled(enabled) {this.musicEnabled = enabled; if (enabled) {this.startBackgroundMusic()}else {this.stopBackgroundMusic()}}isMusicEnabled() {return this.musicEnabled}setMusicVolume(volume) {this.musicVolume = Math.max(0,Math.min(1,volume)); if (this.backgroundMusic && this.backgroundMusic.type !== 'generated') {this.backgroundMusic.volume = this.musicVolume}}getMusicVolume() {return this.musicVolume}getStatus() {return {enabled: this.enabled,volume: this.volume,musicEnabled: this.musicEnabled,musicVolume: this.musicVolume,musicPlaying: this.backgroundMusic ? (this.backgroundMusic.type === 'generated' ? this.backgroundMusic.isPlaying : !this.backgroundMusic.paused) : false,audioContextState: this.audioContext?.state || 'not-available',soundsLoaded: this.sounds.size,sounds: Array.from(this.sounds.keys()) }}}return SoundService;
    };

    __modules__['services/StorageService'] = function(__require__, module, exports) {
        class StorageService {constructor() {this.prefix = 'supermath_'; this.version = '2.0'; this.initStorage()}initStorage() {try {if (!this.isLocalStorageAvailable()) {console.warn('localStorage not available,using memory storage'); this.memoryStorage = new Map()}this.migrateData()}catch (error) {console.error('Error initializing storage:',error); this.memoryStorage = new Map()}}isLocalStorageAvailable() {try {const test = '__storage_test__'; localStorage.setItem(test,test); localStorage.removeItem(test); return true}catch (e) {return false}}migrateData() {const versionKey = this.getKey('version'); const currentVersion = this.get('version','1.0'); if (currentVersion !== this.version) {this.performMigration(currentVersion,this.version); this.set('version',this.version)}}performMigration(fromVersion,toVersion) {console.log(`Migrating storage from ${fromVersion}to ${toVersion}`); if (fromVersion === '1.0') {const oldScore = localStorage.getItem('mathScore'); if (oldScore) {const playerData = {totalScore: parseInt(oldScore) || 0,operationStats: {addition: {score: parseInt(oldScore) || 0,questionsAnswered: 0,correctAnswers: 0 },subtraction: {score: 0,questionsAnswered: 0,correctAnswers: 0 },multiplication: {score: 0,questionsAnswered: 0,correctAnswers: 0 },division: {score: 0,questionsAnswered: 0,correctAnswers: 0 }},achievements: [],settings: {difficulty: 'medium',soundEnabled: true }}; this.savePlayerData(playerData); localStorage.removeItem('mathScore')}}}getKey(key) {return `${this.prefix}${key}`}get(key,defaultValue = null) {try {if (this.memoryStorage) {return this.memoryStorage.get(key) ?? defaultValue}const value = localStorage.getItem(this.getKey(key)); if (value === null) return defaultValue; return JSON.parse(value)}catch (error) {console.error('Error getting from storage:',error); return defaultValue}}set(key,value) {try {if (this.memoryStorage) {this.memoryStorage.set(key,value); return true}localStorage.setItem(this.getKey(key),JSON.stringify(value)); return true}catch (error) {if (error.name === 'QuotaExceededError') {this.handleQuotaExceeded()}console.error('Error setting storage:',error); return false}}remove(key) {try {if (this.memoryStorage) {return this.memoryStorage.delete(key)}localStorage.removeItem(this.getKey(key)); return true}catch (error) {console.error('Error removing from storage:',error); return false}}clear() {try {if (this.memoryStorage) {this.memoryStorage.clear(); return true}const keys = Object.keys(localStorage); keys.forEach(key => {if (key.startsWith(this.prefix)) {localStorage.removeItem(key)}}); return true}catch (error) {console.error('Error clearing storage:',error); return false}}handleQuotaExceeded() {console.warn('Storage quota exceeded,attempting cleanup'); const oldDataKeys = Object.keys(localStorage).filter(key => key.startsWith(this.prefix) && key.includes('backup_') && Date.now() - parseInt(key.split('_').pop()) > 7 * 24 * 60 * 60 * 1000 ); oldDataKeys.forEach(key => localStorage.removeItem(key))}savePlayerData(playerData) {const success = this.set('player',playerData); if (success) {this.set('lastSaved',new Date().toISOString()); const backupKey = `backup_${Date.now()}`; this.set(backupKey,playerData)}return success}getPlayerData() {return this.get('player',null)}saveGameHistory(gameSession) {const history = this.getGameHistory(); history.push(gameSession); if (history.length > 100) {history.splice(0,history.length - 100)}return this.set('gameHistory',history)}getGameHistory() {return this.get('gameHistory',[])}getStorageInfo() {if (this.memoryStorage) {return {type: 'memory',size: this.memoryStorage.size,available: true }}try {let totalSize = 0; Object.keys(localStorage).forEach(key => {if (key.startsWith(this.prefix)) {totalSize += localStorage.getItem(key).length}}); return {type: 'localStorage',usedBytes: totalSize,available: this.isLocalStorageAvailable() }}catch (error) {return {type: 'unknown',error: error.message,available: false }}}exportData() {try {const data = {}; if (this.memoryStorage) {this.memoryStorage.forEach((value,key) => {data[key] = value})}else {Object.keys(localStorage).forEach(key => {if (key.startsWith(this.prefix)) {const cleanKey = key.replace(this.prefix,''); data[cleanKey] = JSON.parse(localStorage.getItem(key))}})}return {version: this.version,exportedAt: new Date().toISOString(),data: data }}catch (error) {console.error('Error exporting data:',error); return null}}importData(exportedData) {try {if (!exportedData || !exportedData.data) {throw new Error('Invalid export data')}Object.entries(exportedData.data).forEach(([key,value]) => {this.set(key,value)}); return true}catch (error) {console.error('Error importing data:',error); return false}}}return StorageService;
    };

    __modules__['ui/components/BlockVisualizer'] = function(__require__, module, exports) {
        class BlockVisualizer {constructor(eventBus) {this.eventBus = eventBus; this.animationDuration = 500; this.maxBlocksPerNumber = 99}drawBlocks(number,container,colorClass,animated = false) {if (!container) {console.error('Container element not found'); return Promise.resolve()}container.innerHTML = ''; if (number > this.maxBlocksPerNumber) {this.drawLargeNumber(number,container,colorClass); return Promise.resolve()}const tens = Math.floor(number / 10); const ones = number % 10; const blocks = []; for (let i = 0; i < tens; i++) {const stack = this.createTenStack(colorClass,animated); blocks.push(...stack.children); container.appendChild(stack)}if (ones > 0) {const stack = this.createOnesStack(ones,colorClass,animated); blocks.push(...stack.children); container.appendChild(stack)}if (animated) {return this.animateBlocks(blocks)}return Promise.resolve()}createTenStack(colorClass,animated = false) {const stack = document.createElement('div'); stack.className = 'ten-stack'; for (let j = 0; j < 10; j++) {const block = this.createBlock(colorClass,animated); stack.appendChild(block)}return stack}createOnesStack(count,colorClass,animated = false) {const stack = document.createElement('div'); stack.className = 'ten-stack'; for (let i = 0; i < count; i++) {const block = this.createBlock(colorClass,animated); stack.appendChild(block)}return stack}createBlock(colorClass,animated = false) {const block = document.createElement('div'); block.className = `block ${colorClass}`; if (animated) {block.style.opacity = '0'; block.style.transform = 'scale(0)'}return block}drawLargeNumber(number,container,colorClass) {container.innerHTML = ` <div class="large-number-display"> <div class="number-value ${colorClass.replace('bg-','text-')}">${number}</div> <div class="number-label">blocks</div> </div> `}animateBlocks(blocks) {return new Promise((resolve) => {if (!blocks || blocks.length === 0) {resolve(); return}const delay = Math.min(50,this.animationDuration / blocks.length); let completedAnimations = 0; blocks.forEach((block,index) => {setTimeout(() => {block.style.transition = `all ${this.animationDuration / 2}ms ease-out`; block.style.opacity = '1'; block.style.transform = 'scale(1)'; block.addEventListener('transitionend',() => {completedAnimations++; if (completedAnimations === blocks.length) {resolve()}},{once: true })},index * delay)}); setTimeout(resolve,this.animationDuration + blocks.length * delay + 100)})}async animateAddition(num1Container,num2Container,answerContainer,num1,num2,result) {await this.drawBlocks(num1,num1Container,'bg-green-400',true); await this.delay(300); await this.drawBlocks(num2,num2Container,'bg-yellow-400',true); await this.delay(500); const answerColorClass = 'bg-blue-400'; await this.drawBlocks(result,answerContainer,answerColorClass,true); this.eventBus.emit('visualizationComplete',{operation: 'addition',result })}async animateSubtraction(num1Container,num2Container,answerContainer,num1,num2,result) {await this.drawBlocks(num1,num1Container,'bg-green-400',true); await this.delay(300); await this.drawBlocks(num2,num2Container,'bg-yellow-400',true); await this.delay(500); await this.animateRemoval(num1Container,num2); await this.delay(300); await this.drawBlocks(result,answerContainer,'bg-blue-400',true); this.eventBus.emit('visualizationComplete',{operation: 'subtraction',result })}async animateMultiplication(num1Container,num2Container,answerContainer,num1,num2,result) {await this.drawBlocks(num1,num1Container,'bg-green-400',true); await this.delay(300); await this.drawBlocks(num2,num2Container,'bg-yellow-400',true); await this.delay(500); await this.animateGrouping(answerContainer,num1,num2,'bg-blue-400'); this.eventBus.emit('visualizationComplete',{operation: 'multiplication',result })}async animateDivision(num1Container,num2Container,answerContainer,dividend,divisor,quotient) {await this.drawBlocks(dividend,num1Container,'bg-green-400',true); await this.delay(300); await this.drawBlocks(divisor,num2Container,'bg-yellow-400',true); await this.delay(500); await this.animateDivisionGrouping(answerContainer,dividend,divisor,quotient); this.eventBus.emit('visualizationComplete',{operation: 'division',result: quotient })}async animateRemoval(container,removeCount) {const blocks = container.querySelectorAll('.block'); const blocksToRemove = Array.from(blocks).slice(-removeCount); return new Promise((resolve) => {let removedCount = 0; blocksToRemove.forEach((block,index) => {setTimeout(() => {block.style.transition = 'all 300ms ease-in'; block.style.opacity = '0'; block.style.transform = 'scale(0)'; setTimeout(() => {block.remove(); removedCount++; if (removedCount === blocksToRemove.length) {resolve()}},300)},index * 50)}); if (blocksToRemove.length === 0) resolve()})}async animateGrouping(container,groups,itemsPerGroup,colorClass) {container.innerHTML = ''; const groupElements = []; for (let g = 0; g < groups; g++) {const groupDiv = document.createElement('div'); groupDiv.className = 'multiplication-group'; groupDiv.style.display = 'inline-block'; groupDiv.style.margin = '0 0.25rem'; groupDiv.style.padding = '0.25rem'; groupDiv.style.border = '2px dashed #ccc'; groupDiv.style.borderRadius = '4px'; const groupBlocks = []; for (let i = 0; i < itemsPerGroup; i++) {const block = this.createBlock(colorClass,true); groupDiv.appendChild(block); groupBlocks.push(block)}container.appendChild(groupDiv); groupElements.push({element: groupDiv,blocks: groupBlocks })}for (let g = 0; g < groupElements.length; g++) {await this.delay(200); await this.animateBlocks(groupElements[g].blocks)}}async animateDivisionGrouping(container,dividend,divisor,quotient) {container.innerHTML = ''; const colors = ['bg-red-300','bg-blue-300','bg-green-300','bg-yellow-300','bg-purple-300']; const groupElements = []; for (let g = 0; g < divisor; g++) {const groupDiv = document.createElement('div'); groupDiv.className = 'division-group'; groupDiv.style.display = 'inline-block'; groupDiv.style.margin = '0 0.25rem'; groupDiv.style.padding = '0.25rem'; groupDiv.style.border = `2px solid ${colors[g % colors.length].replace('bg-','')}`; groupDiv.style.borderRadius = '4px'; groupDiv.style.minHeight = '2rem'; const groupLabel = document.createElement('div'); groupLabel.textContent = `Group ${g + 1}`; groupLabel.style.fontSize = '0.75rem'; groupLabel.style.marginBottom = '0.25rem'; groupDiv.appendChild(groupLabel); container.appendChild(groupDiv); groupElements.push(groupDiv)}for (let i = 0; i < dividend; i++) {const groupIndex = i % divisor; const block = this.createBlock(colors[groupIndex % colors.length],false); groupElements[groupIndex].appendChild(block); block.style.opacity = '0'; block.style.transform = 'scale(0)'; await this.delay(100); block.style.transition = 'all 200ms ease-out'; block.style.opacity = '1'; block.style.transform = 'scale(1)'}}drawMysteryBox(container,colorClass = 'bg-yellow-200') {if (!container) {console.error('Container element not found'); return}container.innerHTML = ''; const mysteryBox = document.createElement('div'); mysteryBox.className = `mystery-box ${colorClass}border-2 border-dashed border-yellow-600`; mysteryBox.innerHTML = ` <div class="mystery-content"> <div class="mystery-symbol">?</div> <div class="mystery-label">Mystery Box</div> </div> `; container.appendChild(mysteryBox)}async animateDetectiveReveal(mysteryContainer,correctAnswer,colorClass = 'bg-blue-400') {const mysteryBox = mysteryContainer.querySelector('.mystery-box'); if (!mysteryBox) return; mysteryBox.style.transition = 'all 500ms ease-out'; mysteryBox.style.transform = 'scale(1.1)'; mysteryBox.style.opacity = '0.8'; await this.delay(300); await this.drawBlocks(correctAnswer,mysteryContainer,colorClass,true); const blocks = mysteryContainer.querySelectorAll('.block'); blocks.forEach((block,index) => {setTimeout(() => {block.style.animation = 'detective-reveal 600ms ease-out'},index * 30)})}async animateDetectiveEquation(equation,containers,problem) {const {num1Container,operatorContainer,num2Container,equalsContainer,resultContainer }= containers; [num1Container,num2Container,resultContainer].forEach(container => {if (container) this.clear(container)}); if (operatorContainer) operatorContainer.textContent = problem.operation; if (equalsContainer) equalsContainer.textContent = '='; if (problem.num1 !== null) {await this.drawBlocks(problem.num1,num1Container,'bg-green-400',true)}else {this.drawMysteryBox(num1Container)}await this.delay(300); if (problem.num2 !== null) {await this.drawBlocks(problem.num2,num2Container,'bg-yellow-400',true)}else {this.drawMysteryBox(num2Container)}await this.delay(300); if (problem.missingPosition === 'result') {this.drawMysteryBox(resultContainer)}else {await this.drawBlocks(problem.result,resultContainer,'bg-purple-400',true)}this.eventBus.emit('visualizationComplete',{operation: 'detective',equation })}async revealDetectiveSolution(containers,problem,userAnswer) {const {num1Container,num2Container,resultContainer }= containers; if (problem.num1 === null) {await this.animateDetectiveReveal(num1Container,userAnswer,'bg-green-400')}else if (problem.num2 === null) {await this.animateDetectiveReveal(num2Container,userAnswer,'bg-yellow-400')}else if (problem.missingPosition === 'result') {await this.animateDetectiveReveal(resultContainer,userAnswer,'bg-purple-400')}this.addCaseClosedEffect(containers)}addCaseClosedEffect(containers) {Object.values(containers).forEach(container => {if (!container) return; const effect = document.createElement('div'); effect.className = 'case-closed-effect'; effect.textContent = 'üïµÔ∏è CASE CLOSED! üéØ'; effect.style.cssText = ` position: absolute; top: -20px; left: 50%; transform: translateX(-50%); background: linear-gradient(45deg,#ffd700,#ffed4e); color: #2d3748; padding: 0.5rem 1rem; border-radius: 20px; font-weight: bold; font-size: 0.8rem; z-index: 10; animation: case-closed-popup 2s ease-out forwards; pointer-events: none; `; container.style.position = 'relative'; container.appendChild(effect); setTimeout(() => {if (effect.parentNode) {effect.parentNode.removeChild(effect)}},2000)})}delay(ms) {return new Promise(resolve => setTimeout(resolve,ms))}setAnimationDuration(duration) {this.animationDuration = Math.max(100,Math.min(2000,duration))}getAnimationDuration() {return this.animationDuration}clear(container) {if (container) {container.innerHTML = ''}}}return BlockVisualizer;
    };

    __modules__['ui/components/ModalManager'] = function(__require__, module, exports) {
        class ModalManager {constructor(eventBus) {this.eventBus = eventBus; this.activeModals = new Map(); this.modalStack = []; this.setupEventListeners()}setupEventListeners() {document.addEventListener('keydown',(e) => {if (e.key === 'Escape' && this.modalStack.length > 0) {const topModal = this.modalStack[this.modalStack.length - 1]; if (topModal.closable !== false) {this.close(topModal.id)}}}); document.addEventListener('click',(e) => {if (e.target.classList.contains('modal-backdrop')) {const modalId = e.target.dataset.modalId; const modal = this.activeModals.get(modalId); if (modal && modal.closable !== false) {this.close(modalId)}}})}create(id,options = {}) {if (this.activeModals.has(id)) {console.warn(`Modal ${id}already exists`); return this.activeModals.get(id)}const modal = {id,title: options.title || '',content: options.content || '',type: options.type || 'default',size: options.size || 'medium',closable: options.closable !== false,showHeader: options.showHeader !== false,showFooter: options.showFooter !== false,buttons: options.buttons || [],onShow: options.onShow || null,onHide: options.onHide || null,onDestroy: options.onDestroy || null,className: options.className || '',element: null }; const modalElement = this.createModalElement(modal); modal.element = modalElement; this.activeModals.set(id,modal); document.body.appendChild(modalElement); return modal}createModalElement(modal) {const backdrop = document.createElement('div'); backdrop.className = `modal-backdrop fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50 opacity-0 transition-opacity duration-300`; backdrop.dataset.modalId = modal.id; backdrop.style.visibility = 'hidden'; const modalContent = document.createElement('div'); modalContent.className = this.getModalSizeClass(modal.size,modal.type); modalContent.innerHTML = this.getModalHTML(modal); this.setupModalEventListeners(modalContent,modal); backdrop.appendChild(modalContent); return backdrop}getModalSizeClass(size,type) {const baseClasses = 'bg-white rounded-2xl shadow-2xl transform scale-95 transition-transform duration-300 max-h-screen overflow-auto'; const typeClasses = {success: 'bg-green-50',error: 'bg-red-50',warning: 'bg-yellow-50',info: 'bg-blue-50',default: 'bg-white' }; const sizeClasses = {small: 'w-full max-w-sm',medium: 'w-full max-w-lg',large: 'w-full max-w-2xl',xlarge: 'w-full max-w-4xl',full: 'w-full h-full max-w-none' }; return `${baseClasses}${typeClasses[type] || typeClasses.default}${sizeClasses[size] || sizeClasses.medium}`}getModalHTML(modal) {let html = ''; if (modal.showHeader) {html += ` <div class="modal-header flex justify-between items-center p-6 border-b"> <h2 class="text-2xl font-bold ${this.getTypeColorClass(modal.type)}">${modal.title}</h2> ${modal.closable ? '<button class="modal-close text-gray-400 hover:text-gray-600 text-2xl font-bold">&times;</button>' : ''}</div> `}html += ` <div class="modal-body p-6"> ${modal.content}</div> `; if (modal.showFooter && modal.buttons.length > 0) {html += ` <div class="modal-footer flex gap-3 justify-center p-6 border-t"> ${modal.buttons.map(button => this.getButtonHTML(button)).join('')}</div> `}return html}getTypeColorClass(type) {const colorClasses = {success: 'text-green-600',error: 'text-red-600',warning: 'text-yellow-600',info: 'text-blue-600',default: 'text-gray-800' }; return colorClasses[type] || colorClasses.default}getButtonHTML(button) {const baseClasses = 'px-6 py-3 rounded-xl font-bold text-lg transition-colors duration-200'; const typeClasses = {primary: 'bg-blue-500 hover:bg-blue-600 text-white',success: 'bg-green-500 hover:bg-green-600 text-white',danger: 'bg-red-500 hover:bg-red-600 text-white',warning: 'bg-yellow-500 hover:bg-yellow-600 text-white',secondary: 'bg-gray-200 hover:bg-gray-300 text-gray-700',outline: 'border-2 border-gray-300 hover:border-gray-400 text-gray-700' }; const buttonClass = `${baseClasses}${typeClasses[button.type] || typeClasses.secondary}`; return `<button class="modal-button ${buttonClass}" data-action="${button.action || ''}">${button.text}</button>`}setupModalEventListeners(modalContent,modal) {if (modal.closable) {const closeBtn = modalContent.querySelector('.modal-close'); if (closeBtn) {closeBtn.addEventListener('click',() => this.close(modal.id))}}const buttons = modalContent.querySelectorAll('.modal-button'); buttons.forEach(button => {button.addEventListener('click',(e) => {const action = e.target.dataset.action; this.handleButtonClick(modal.id,action,e)})})}handleButtonClick(modalId,action,event) {this.eventBus.emit('modalButtonClick',{modalId,action,event }); if (action === 'close') {this.close(modalId)}}show(id) {const modal = this.activeModals.get(id); if (!modal) {console.error(`Modal ${id}not found`); return false}this.modalStack.push(modal); modal.element.style.visibility = 'visible'; requestAnimationFrame(() => {modal.element.classList.remove('opacity-0'); modal.element.classList.add('opacity-100'); const content = modal.element.querySelector('div'); content.classList.remove('scale-95'); content.classList.add('scale-100')}); if (modal.onShow) {modal.onShow(modal)}this.eventBus.emit('modalShown',{modalId: id }); return true}hide(id) {const modal = this.activeModals.get(id); if (!modal) {console.error(`Modal ${id}not found`); return false}modal.element.classList.remove('opacity-100'); modal.element.classList.add('opacity-0'); const content = modal.element.querySelector('div'); content.classList.remove('scale-100'); content.classList.add('scale-95'); setTimeout(() => {modal.element.style.visibility = 'hidden'},300); this.modalStack = this.modalStack.filter(m => m.id !== id); if (modal.onHide) {modal.onHide(modal)}this.eventBus.emit('modalHidden',{modalId: id }); return true}close(id) {this.hide(id); setTimeout(() => this.destroy(id),300)}destroy(id) {const modal = this.activeModals.get(id); if (!modal) return false; if (modal.element && modal.element.parentNode) {modal.element.parentNode.removeChild(modal.element)}if (modal.onDestroy) {modal.onDestroy(modal)}this.activeModals.delete(id); this.eventBus.emit('modalDestroyed',{modalId: id }); return true}updateContent(id,content) {const modal = this.activeModals.get(id); if (!modal) return false; const bodyElement = modal.element.querySelector('.modal-body'); if (bodyElement) {bodyElement.innerHTML = content; return true}return false}isOpen(id) {const modal = this.activeModals.get(id); return modal && this.modalStack.includes(modal)}closeAll() {const modalIds = Array.from(this.activeModals.keys()); modalIds.forEach(id => this.close(id))}showFeedbackModal(isCorrect,questionData,onNext,onExplain) {const modalId = 'feedback'; this.destroy(modalId); const buttons = [ {text: 'Next Question',type: isCorrect ? 'success' : 'danger',action: 'next' }]; if (!isCorrect && onExplain) {buttons.push({text: '‚ú® Explain This For Me',type: 'warning',action: 'explain' })}const modal = this.create(modalId,{title: isCorrect ? 'Correct!' : 'Try Again!',content: this.getFeedbackContent(isCorrect,questionData),type: isCorrect ? 'success' : 'error',buttons: buttons,closable: false }); this.eventBus.on('modalButtonClick',(data) => {if (data.modalId === modalId) {if (data.action === 'next' && onNext) {onNext()}else if (data.action === 'explain' && onExplain) {onExplain()}}}); this.show(modalId); return modal}getFeedbackContent(isCorrect,questionData) {const {num1,num2,operation,correctAnswer,expression }= questionData; if (isCorrect) {const problemText = expression || `${num1}${operation}${num2}`; return `<p class="text-xl mb-4">Great job! ${problemText}= ${correctAnswer}.</p>`}else {const problemText = expression || `${num1}${operation}${num2}`; return ` <p class="text-xl mb-4">Not quite. The correct answer was ${correctAnswer}. You'll get the next one!</p> <div id="explanation-container" class="bg-gray-100 p-4 rounded-lg mt-4 text-left text-base hidden"> <div id="explanation-loader" class="loader hidden"></div> <div id="explanation-text"></div> </div> `}}showExplanation(explanation) {const explanationContainer = document.getElementById('explanation-container'); const explanationText = document.getElementById('explanation-text'); const explanationLoader = document.getElementById('explanation-loader'); if (explanationContainer && explanationText && explanationLoader) {explanationContainer.classList.remove('hidden'); explanationLoader.classList.add('hidden'); explanationText.innerHTML = explanation}}showLoadingExplanation() {const explanationContainer = document.getElementById('explanation-container'); const explanationText = document.getElementById('explanation-text'); const explanationLoader = document.getElementById('explanation-loader'); if (explanationContainer && explanationText && explanationLoader) {explanationContainer.classList.remove('hidden'); explanationLoader.classList.remove('hidden'); explanationText.innerHTML = ''}}}return ModalManager;
    };

    __modules__['ui/components/ScoreDisplay'] = function(__require__, module, exports) {
        class ScoreDisplay {constructor(eventBus) {this.eventBus = eventBus; this.elements = new Map(); this.animationQueue = []; this.isAnimating = false}register(elementId,type = 'total') {const element = document.getElementById(elementId); if (!element) {console.error(`Score display element ${elementId}not found`); return false}this.elements.set(elementId,{element,type,lastValue: 0,animationDuration: 800 }); return true}update(elementId,value,animated = true) {const scoreElement = this.elements.get(elementId); if (!scoreElement) {console.error(`Score element ${elementId}not registered`); return}if (animated && value !== scoreElement.lastValue) {this.animateScoreChange(elementId,scoreElement.lastValue,value)}else {this.setDisplayValue(scoreElement,value)}scoreElement.lastValue = value}animateScoreChange(elementId,fromValue,toValue) {this.animationQueue.push({elementId,fromValue,toValue,startTime: null }); if (!this.isAnimating) {this.processAnimationQueue()}}processAnimationQueue() {if (this.animationQueue.length === 0) {this.isAnimating = false; return}this.isAnimating = true; const animation = this.animationQueue.shift(); const scoreElement = this.elements.get(animation.elementId); if (!scoreElement) {this.processAnimationQueue(); return}const startTime = performance.now(); const duration = scoreElement.animationDuration; const difference = animation.toValue - animation.fromValue; const animate = (currentTime) => {const elapsed = currentTime - startTime; const progress = Math.min(elapsed / duration,1); const easeOutQuart = 1 - Math.pow(1 - progress,4); const currentValue = Math.round(animation.fromValue + (difference * easeOutQuart)); this.setDisplayValue(scoreElement,currentValue); if (progress < 1) {requestAnimationFrame(animate)}else {this.setDisplayValue(scoreElement,animation.toValue); this.addScoreChangeEffect(scoreElement.element,difference); setTimeout(() => {this.processAnimationQueue()},100)}}; requestAnimationFrame(animate)}setDisplayValue(scoreElement,value) {const displayText = this.formatScore(value,scoreElement.type); scoreElement.element.textContent = displayText; this.eventBus.emit('scoreDisplayUpdated',{elementId: Array.from(this.elements.entries()) .find(([_,el]) => el === scoreElement)?.[0],value,type: scoreElement.type })}formatScore(value,type) {switch (type) {case 'total': return `Score: ${value.toLocaleString()}`; case 'level': return `Level: ${value}`; case 'streak': return `Streak: ${value}`; case 'accuracy': return `Accuracy: ${value}%`; case 'operation': return value.toLocaleString(); default: return value.toString()}}addScoreChangeEffect(element,difference) {if (difference <= 0) return; const effectElement = document.createElement('div'); effectElement.className = 'score-change-effect'; effectElement.textContent = `+${difference}`; effectElement.style.cssText = ` position: absolute; top: -20px; right: 0; color: #10B981; font-weight: bold; font-size: 1.2em; pointer-events: none; opacity: 1; transform: translateY(0); transition: all 1s ease-out; z-index: 10; `; const rect = element.getBoundingClientRect(); effectElement.style.left = `${rect.right - 50}px`; effectElement.style.top = `${rect.top - 20}px`; effectElement.style.position = 'fixed'; document.body.appendChild(effectElement); requestAnimationFrame(() => {effectElement.style.opacity = '0'; effectElement.style.transform = 'translateY(-30px)'}); setTimeout(() => {if (effectElement.parentNode) {effectElement.parentNode.removeChild(effectElement)}},1000)}createScoreBoard(player) {const operations = ['addition','subtraction','multiplication','division','supermode']; let html = ` <div class="score-board bg-white rounded-lg p-6 shadow-lg"> <h3 class="text-2xl font-bold mb-4 text-center">Score Summary</h3> <div class="total-score text-center mb-6"> <div class="text-4xl font-black text-blue-600">${player.totalScore.toLocaleString()}</div> <div class="text-gray-600">Total Points</div> </div> <div class="level-info text-center mb-6"> <div class="text-2xl font-bold text-purple-600">Level ${player.level}</div> <div class="text-sm text-gray-600">Streak: ${player.streak}| Best: ${player.bestStreak}</div> </div> <div class="operation-breakdown"> <h4 class="font-bold mb-3">By Operation:</h4> `; operations.forEach(operation => {const stats = player.operationStats[operation]; const accuracy = player.getAccuracy(operation); const operationName = operation.charAt(0).toUpperCase() + operation.slice(1); html += ` <div class="operation-row flex justify-between items-center mb-2 p-2 bg-gray-50 rounded"> <span class="font-medium">${operationName}</span> <div class="text-right"> <div class="text-lg font-bold text-blue-600">${stats.score}</div> <div class="text-xs text-gray-600">${stats.correctAnswers}/${stats.questionsAnswered}(${accuracy}%)</div> </div> </div> `}); html += ` </div> </div> `; return html}createMiniScoreDisplay(score,level,streak) {return ` <div class="mini-score-display flex items-center gap-4 text-sm"> <div class="score-item"> <span class="label text-gray-600">Score:</span> <span class="value font-bold text-blue-600">${score.toLocaleString()}</span> </div> <div class="score-item"> <span class="label text-gray-600">Level:</span> <span class="value font-bold text-purple-600">${level}</span> </div> <div class="score-item"> <span class="label text-gray-600">Streak:</span> <span class="value font-bold text-green-600">${streak}</span> </div> </div> `}animateAchievementScore(points) {const achievementScore = document.createElement('div'); achievementScore.className = 'achievement-score-popup'; achievementScore.innerHTML = ` <div class="text-center p-4 bg-yellow-100 border-2 border-yellow-400 rounded-lg shadow-lg"> <div class="text-2xl font-bold text-yellow-600 mb-2">üèÜ Achievement!</div> <div class="text-lg font-bold text-yellow-700">+${points}bonus points!</div> </div> `; achievementScore.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%,-50%) scale(0); z-index: 1000; transition: all 0.5s ease-out; `; document.body.appendChild(achievementScore); requestAnimationFrame(() => {achievementScore.style.transform = 'translate(-50%,-50%) scale(1)'}); setTimeout(() => {achievementScore.style.opacity = '0'; achievementScore.style.transform = 'translate(-50%,-50%) scale(0.8)'},2000); setTimeout(() => {if (achievementScore.parentNode) {achievementScore.parentNode.removeChild(achievementScore)}},2500)}setAnimationDuration(elementId,duration) {const scoreElement = this.elements.get(elementId); if (scoreElement) {scoreElement.animationDuration = Math.max(200,Math.min(2000,duration))}}reset(elementId) {const scoreElement = this.elements.get(elementId); if (scoreElement) {scoreElement.lastValue = 0; this.setDisplayValue(scoreElement,0)}}resetAll() {this.elements.forEach((scoreElement,elementId) => {this.reset(elementId)}); this.animationQueue = []; this.isAnimating = false}}return ScoreDisplay;
    };


    // Initialize the app
    try {
        const app = __require__('app');
        window.mathSuperGameApp = app;
        console.log('Math Super Game loaded successfully');
    } catch (error) {
        console.error('Failed to initialize Math Super Game:', error);
    }
})();
